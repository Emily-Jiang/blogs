---
layout: post
title: "A Solution to Configuration Drift - Deploying Open Liberty with GitOps"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/danielguinan1
author_github: https://github.com/danielguinan1
seo-title: TITLE - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: "DESCRIPTION"
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
additional_authors: 
- name: Monica Tamboli
  github: https://github.com/mtamboli
  image: https://avatars0.githubusercontent.com/mtamboli
---
= A Solution to Configuration Drift - Deploying Open Liberty with GitOps 
Daniel Guinan <https://github.com/danielguinan1>
:imagesdir: /
:url-prefix:
:url-about: /

Many organizations are struggling with configuration drift, and GitOps provides a robust solution. In this blog, we will demonstrate the deployment of an Open Liberty application to a Kubernetes cluster using a continuous deployment approach with GitOps—a framework for managing deployments through version-controlled configuration. This blog utilizes ArgoCD, a leading GitOps tool designed to automate application deployment and ensure configuration consistency, effectively addressing the drift issue.

== Getting your Cluster Ready ==
In this blog, we assume you have some form of kubernetes cluster, which you have access to using the `kubectl` CLI.  

=== Using the Open Liberty Operator ===

The Open Liberty Operator streamlines the deployment and management of Open Liberty Applications on Kubernetes. Instead of manually crafting Kubernetes resources for the application (like services, deployments, routes, etc.), the Operator enables us to define a few application details, and it automatically generates the required Kubernetes resources. Furthermore, it simplifies day 2 operations such as traces and heap dumps when needed. For more on the Open Liberty Operator check out their docs [here.](https://openliberty.io/docs/latest/open-liberty-operator.html)

To take advantage of all of these benefits, we can make use of the Open Liberty Operator to deploy an application using the following commands, which install the operator with its default configuration (watching all namespaces):
```
git clone https://github.com/OpenLiberty/open-liberty-operator.git
kubectl create namespace open-liberty
kubectl apply --server-side -k open-liberty-operator/deploy/releases/1.2.2/kustomize/overlays/watch-all-namespaces
```

=== Using ArgoCD for effective GitOps and Continuous Delivery ===
ArgoCD follows a GitOps pattern of using Git repositories as the source of truth for defining the desired application state, which we will use to deploy and monitor our Open Liberty configuration repository.  ArgoCD will help us identify any drift that occurs between the current cluster state and the desired state in the configuration repository.  

To install ArgoCD simply run these commands from the Quickstart section <https://argo-cd.readthedocs.io/en/stable/getting_started/> of the docs:
We'll use the following commands to create a new namespace named `argocd` and install ArgoCD by applying manifests to that namespace.
```
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
```

Next we'll get the default Admin credentials to access the ArgoCD user interface.  Using the UI is a great way to get started, allowing us to create our application and identify configuration drift in a visual way.
To get the default Admin password run the following command:
```
kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 -d
```
To access the ArgoCD UI, go to the route of the `argocd-server` and log with the `admin` user and password.
[.img_border_light]
image::/img/blog/configuration-drift-1.png[Argo Login,width=70%,align="center"]

Once logged in, you should see the ArgoCD landing page similar to the screenshot below:
[.img_border_light]
image::/img/blog/configuration-drift-2.png[Argo Home,width=70%,align="center"]

== Setting up a GitOps Repository for your Application ==
Now that you've successfully installed ArgoCD and gained access to its console, the next step is to set up a GitHub repository for ArgoCD to synchronize with.  In our example we have created a deployment directory in the application code repo which we will point ArgoCD to for deployment.  In our experience we found it better to separate the deployment configuration into a separate repository from the application code, however for this small example we have it with the application code.  It's a recommended best practice to maintain separation between configuration repositories and code repositories. Keeping these separate ensures that infrastructure changes are decoupled from application changes, allowing for more granular control, better audit trails, and reduced risk of unintended side-effects.  The reasons why can be found on ArgoCD's site regarding best practices: https://argo-cd.readthedocs.io/en/stable/user-guide/best_practices/

For the purposes of this blog, we'll use the Daytrader7 sample application. This application is built around the concept of an online stock trading system, and the Daytrader7 README (https://github.com/WASdev/sample.daytrader7#readme) provides a comprehensive overview.

In this example, we have a `deploy` directory within our existing repository to house the deployment configuration.  This directory contains the manifests for full application deployment as well as annotations telling ArgoCD which order they should be deployed in.  

To begin, navigate to GitHub and fork this repository: https://github.com/WASdev/sample.daytrader7. Use your forked repository when configuring ArgoCD in the following steps.

In this example, we have a pre-built container image pushed to Docker Hub that is used in the deployment files `deploy/daytrader7-deploy.yaml`.  For more information on containerizing your application check out this guide here(https://openliberty.io/guides/docker.html).

== Deploying a Java application with GitOps ==

Now that we have the Git repository forked and ready for deployment, it’s time to configure ArgoCD to deploy the application.

First we'll go to the ArgoCD console dashboard that we saw before.
Next we'll click the New App button near the top left of the console.  This opens a window where we will give ArgoCD the details on the application we want to deploy.
For Application name, let’s call this one daytrader7, keeping it in the default ArgoCD project and setting the sync policy to Manual. We will check the Auto-Create Namespace box which creates the namespace if it doesn't already exist.  The ArgoCD project is a way to group Applications together for large scale deployment of applications (which is not needed in our case).  Sync Policy determines whether we want ArgoCD to automatically correct configuration drift or wait for us to manually do it tell it to.  
[.img_border_light]
image::/img/blog/configuration-drift-3.png[Creating the App,width=70%,align="center"]
Next we will scroll down to the Source and change the Repository URL to your newly forked repo. This tells ArgoCD what git repository has the configuration for the application you are looking to deploy. 
 Next we'll change the path, which is the path in the git repo where ArgoCD is looking for deployment files to deploy. For the the Cluster URL we will set it to https://kubernetes.default.svc, which is the local cluster URL. Then, lastly, we will set the namespace to daytrader7 (which will be created because we selected the "Auto-Create Namespace" option).
After verifying these options, click Create in the top left.
[.img_border_light]
image::/img/blog/configuration-drift-4.png[Setting the Repo,width=70%,align="center"]

=== Manually Syncing your Application with the Repository ===
Since we chose manual sync policy in the options for demonstrative purposes, we have to sync the application manually for ArgoCD to deploy the application.  On the main page of the ArgoCD console, you should see a new tile that looks like this:
[.img_border_light]
image::/img/blog/configuration-drift-5.png[Argo Dashboard,width=70%,align="center"]
Click the Sync button, then on the window that appears click Sync again.
To monitor the progress of this application sync, you can click on the daytrader7 tile.
Over the course of a few minutes, you should see resources being created and the app dashboard should look like this:
[.img_border_light]
image::/img/blog/configuration-drift-6.png[App deploying,width=70%,align="center"]
This diagram shows the many kubernetes resources created for the application, such as the deployment, pod, and service.  We can also monitor the health of each of these resources and verify they were created properly.  
Now the app is deployed and can be reached in a route created under the daytrader7 namespace. Find the URL via `oc get routes –n daytrader7`, then paste the URL in a browser.
And there we go! The app is fully deployed and ready to be used.
[.img_border_light]
image::/img/blog/configuration-drift-7.png[Daytrader Home,width=70%,align="center"]
== See how GitOps can solve Configuration Drift ==
Now that we have the app deployed let's show a scenario where configuration drift occurs and how we can easily correct it.
Let's say a developer changes the memory settings in the configuration file for a quick test.  To represent this, change the memory request for the deploy/daytrader7-deploy.yaml file from 1024Mi to 2048Mi using either the Kubernetes CLI or the console itself.  In a few moments the argo console should show it is out of sync:
[.img_border_light]
image::/img/blog/configuration-drift-outofsync.png[Daytrader Home,width=70%,align="center"]
"Out of Sync" means that some form of configuration drift occured in the application.  We can refer back to the diagram to tell exactly where it occured.  
Since we set Auto-Sync to disable earlier in this blog, we have to manually tell ArgoCD to correct the configuration drift.  To do this, click on the `Sync` button to return the configuration to match what git says it should be.

[.img_border_light]
image::/img/blog/configuration-drift-synced.png[Daytrader Home,width=70%,align="center"]

// // // // // // // //
// LINKS
//
// OpenLiberty.io site links:
// link:/guides/microprofile-rest-client.html[Consuming RESTful Java microservices]
// 
// Off-site links:
// link:https://openapi-generator.tech/docs/installation#jar[Download Instructions]
//
// // // // // // // //

== Next Steps ==
In this blog post, we've explored the seamless deployment of Open Liberty applications through the GitOps methodology, highlighting its effectiveness in mitigating configuration drift. Whether you're seeking to refine your deployment strategy or embark on a fresh project for Open Liberty application, we encourage experimenting with GitOps. This approach can be easily extended to automate the deployment of other dependencies like databases for your applications.

And for those looking to create or update Open Liberty applications, the open liberty guides available at openliberty.io offer helpful insights and steps.
