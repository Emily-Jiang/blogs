---
layout: post
title: "A Solution to Configuration Drift - Deploying Open Liberty with GitOps"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/danielguinan1
author_github: https://github.com/danielguinan1
seo-title: TITLE - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: "DESCRIPTION"
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
additional_authors: 
- name: Monica Tamboli
  github: https://github.com/SECOND_GITHUB_USERNAME
  image: https://avatars0.githubusercontent.com/SECOND_GITHUB_USERNAME
- name: THIRD_AUTHOR_NAME
  github: https://github.com/THIRD_GITHUB_USERNAME
  image: https://avatars0.githubusercontent.com/THIRD_GITHUB_USERNAME
---
= A Solution to Configuration Drift - Deploying Open Liberty with GitOps 
Daniel Guinan <https://github.com/GITHUB_USERNAME>
:imagesdir: /
:url-prefix:
:url-about: /
//Blank line here is necessary before starting the body of the post.

// // // // // // // //
// In the preceding section:
// Do not insert any blank lines between any of the lines.
//
// "open-graph-image" is set to OL logo. Whenever possible update this to a more appropriate/specific image (for example if present an image that is being used in the post). 
// However, it can be left empty which will set it to the default
//
// "open-graph-image-alt" is a description of what is in the image (not a caption). When changing "open-graph-image" to
// a custom picture, you must provide a custom string for "open-graph-image-alt".
//
// Replace TITLE with the blog post title
//
// Replace SECOND_AUTHOR_NAME with the name of the second author.
// Replace SECOND_GITHUB_USERNAME with the GitHub user name of the second author.
// Replace THIRD_AUTHOR_NAME with the name of the third author. And so on for fourth, fifth, etc authors.
// Replace THIRD_GITHUB_USERNAME with the GitHub user name of the third author. And so on for fourth, fifth, etc authors.
//
// Replace AUTHOR_NAME with your name as first author.
// Replace GITHUB_USERNAME with your GitHub username eg: lauracowen
// Replace DESCRIPTION with a short summary (~60 words) of the release (a more succinct version of the first paragraph of the post).
//
// Replace AUTHOR_NAME with your name as you'd like it to be displayed, eg: Laura Cowen
//
// Example post: 2020-02-12-faster-startup-Java-applications-criu.adoc
//
// If adding image into the post add :
// -------------------------
// [.img_border_light]
// image::img/blog/FILE_NAME[IMAGE CAPTION ,width=70%,align="center"]
// -------------------------
// "[.img_border_light]" = This adds a faint grey border around the image to make its edges sharper. Use it around
// screenshots but not around diagrams. Then double check how it looks.
// There is also a "[.img_border_dark]" class which tends to work best with screenshots that are taken on dark backgrounds.
// Once again make sure to double check how it looks
// Change "FILE_NAME" to the name of the image file. Also make sure to put the image into the right folder which is: img/blog
// change the "IMAGE CAPTION" to a couple words of what the image is
// // // // // // // //
In today's modern software ecosystem, while many organizations have embraced Continuous Integration and Continuous Deployment (CI/CD) methodologies, they still grapple with the persistent issue of configuration drift. This refers to the disparity between configurations as coded in repositories like Git and what's actively deployed. This drift not only complicates deployments but can also jeopardize the stability of production environments. So, how can we reconcile this gap and ensure consistency across our deployments?

The answer lies in GitOps — a principle that revolves around using Git as the single source of truth for declarative infrastructure and applications. In this blog, we delve into harnessing the power of the GitOps framework and the deployment tool ArgoCD, to combat configuration drift. As a practical example, we'll spotlight the deployment of Open Liberty applications—a lightweight cloud-native Java runtime—onto Kubernetes/OpenShift clusters. And while our demonstration leans on specific tools; you can seamlessly integrate the CI/CD tools of your preference.

== What is Configuration Drift? ==
Configuration drift is defined as the divergence of a system’s active configuration from its intended or expected state. While there can be different reasons for this drift, the most common cause is manual untracked changes made to a system. If unaddressed, drift can be time-consuming to rectify especially when scale of the system increases. Configuration drift can also pose security risks, such as unpatched vulnerabilities or absent security protocols.

As an example, imagine a scenario where a Continuous Deployment (CD) pipeline deploys an application to a Kubernetes cluster, with all configurations codified in a Git repository. Everything operates seamlessly. However, a team member identifies a performance issue and, aiming for a quick fix, uses a kubectl command to directly tweak the resource allocations for a specific deployment. Although this might resolve the immediate problem, the cluster's state now diverges from what's documented in Git. The next time a deployment occurs, unexpected behaviors might arise because the CD pipeline assumes the cluster matches the Git state. Additionally, other team members might remain unaware of this change, leading to potential troubleshooting challenges and operational inefficiencies down the line.

== What is GitOps ==   
GitOps is a framework designed to streamline and optimize how operations and infrastructure are handled in the modern cloud-native landscape. GitOps revolves around four core principles:

* 		Declarative Configuration: In GitOps, all resources and infrastructure are defined declaratively. This means the entire system – from infrastructure, networking, and even application deployments – is described in a manner where you state "what" you want, not "how" to achieve it. These declarations are usually made through config files or manifests.

* 		Versioned and Immutable Source of Truth: Every declared configuration is stored in a version-controlled Git repository. This repository acts as the immutable source of truth for both infrastructure and application. Any change, be it a minor configuration tweak or a major system overhaul, is recorded as a commit, ensuring full traceability and history.

* 		Automated Delivery: Once a change is committed to the Git repository, automated processes handle the deployment. This ensures that the live system is always in sync with the repository's declared state. If any difference arises – whether due to manual interventions, system failures, or other reasons – the GitOps process can either flag it or work to reconcile the live state to match the repository.

* 		Closed-Loop Feedback & Control: Continuous feedback is integral to GitOps. Monitoring and alerting tools keep a watchful eye on the live environment, comparing its state to the repository. If discrepancies are detected, these tools alert operations teams or even trigger auto-correction processes, making sure the desired state, as defined in Git, is consistently maintained.

In essence, GitOps is more than just a set of tools or practices. It's a cultural shift in how infrastructure and applications are managed, drawing from proven development practices and extending them to operations. By tightly integrating Git at the center of the operational framework, GitOps ensures reliability, transparency, and efficiency in modern deployment pipelines.

== What is GitOps/ArgoCD == 

After understanding the principles of GitOps, it becomes evident that achieving its full potential requires tools designed with these principles in mind. ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes.

ArgoCD works by ensuring that a Kubernetes cluster's state matches the configurations defined in a Git repository. It facilitates the automatic deployment and synchronization of applications to the desired environments. 

Typical Continuous Deployment (CD) systems adhere to the first two GitOps principles: using declarative configurations and maintaining a versioned, immutable source of truth. They ensure that every piece of infrastructure or application change is defined declaratively and then stored in a version-controlled system like Git. However, when it comes to the latter two principles, ensuring automated delivery and maintaining closed-loop feedback & control, this is where many CD systems fall short, and tools like ArgoCD shine.

* 		Automated Delivery: ArgoCD continuously and automatically syncs applications when changes are committed to the Git repository. This ensures deployments are consistent with the repository, bridging the gap between development commits and operational deployments.

* 		Closed-Loop Feedback & Control: ArgoCD's real-time monitoring of application performance ensures that the live state is always aligned with the Git repository's state. If a discrepancy is detected, ArgoCD offers visual representations of the divergence and provides mechanisms to reconcile those differences, ensuring constant alignment with the intended state.
== SVT GitOps Pipeline ==

== Our SVT Pipeline ==

[.img_border_light]
image::/img/blog/configuration-drift-chart.png[SVT DevOps pipeline,width=70%,align="center"]

This blog will focus more on the CD aspect of GitOps, however, in order to effectively deploy with GitOps it is crucial to have a solid CI pipeline in place to build your Open Liberty Applications.  In our experience we found it more effective to separate the CI/CD pipelines into two smaller, less complex pipelines.  This also allowed us to reuse our existing pipeline and use tools we were already familiar with.  If you have no existing CI pipeline there are many great tools out there that can be used to build a pipeline, including open source options of Jenkins and Tekton.  Our CI pipeline consists of compiling the code upon commit, running tests, running security scans, and finally building a Docker image to be deployed with our CD pipeline.  Each of these tools used is interchangable with whichever tool is preferred, but as an example these are the ones we used.

== Install ArgoCD ==
To install ArgoCD simply run these commands from the Quickstart section of the docs:
```
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
```
This will create a new namespace named argocd as well as apply the install manifests to that namespace.  It alternatively can be installed via OLM.

== Install the Open Liberty Operator ==
The Open Liberty Operator assists in the deployment and management of Open Liberty Applications on Kubernetes.  To install it with the default configuration of watching all namespaces, clone the repository and run the following commands:
```
git clone https://github.com/OpenLiberty/open-liberty-operator.git
kubectl create namespace open-liberty
kubectl apply --server-side -k open-liberty-operator/deploy/releases/1.2.2/kustomize/overlays/watch-all-namespaces
```

== Using ArgoCD ==
Get the default Admin password using the following command:
```
kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 -d
```
Next, go to the route of the `argocd-server` and log with the `admin` user and password.
[.img_border_light]
image::/img/blog/configuration-drift-1.png[Liberty Dashboard,width=70%,align="center"]

Once logged, in you should see this page:
[.img_border_light]
image::/img/blog/configuration-drift-2.png[Liberty Dashboard,width=70%,align="center"]

== Creating a repo to be used for GitOps ==
Now that ArgoCD is installed and we have access to the console, it’s time to create a repository on GitHub for Argo CD to sync to.

We will use the Daytrader7 sample application, which is an application built around the paradigm of an online stock trading system. For more information about the Daytrader7 sample app and its usage, check out the Daytrader7 README. The repo being tracked can also be entirely separate from the code as well.

On GitHub, create a fork of https://github.com/WASdev/sample.daytrader7.

== Building the Application ==
Run `mvn clean package` to package the source.
Build the container image with docker build -t sample-daytrader7 -f Containerfile_db2.
Upload the image to an image repo that OpenShift can access (Docker Hub or Quay, for example)
In your forked repo, update the ApplicationImage field in deploy/daytrader7-deploy.yaml with your newly uploaded image.

== Deploying DayTrader 7 via GitOps ==
Now that we have the Git source and image repository ready for deployment, it’s time to use GitOps to deploy the application.

Go to the Argo CD console and ensure that you are logged in.
Click the New App button near the top left of the console.
For Application name, let’s call this one daytrader7, keeping it in the default Argo project and setting the sync policy to Manual. Check the Auto-Create Namespace box as well.
[.img_border_light]
image::/img/blog/configuration-drift-3.png[Liberty Dashboard,width=70%,align="center"]
Scroll down to the Source and change the Repository URL to your newly forked repo. Change the path, which is the path where Argo CD is looking for deployment files, to deploy. Set the Cluster URL to https://kubernetes.default.svc, which is the local cluster URL. Then set the namespace to daytrader7
Click Create in the top left.
[.img_border_light]
image::/img/blog/configuration-drift-4.png[Liberty Dashboard,width=70%,align="center"]

== Syncing DayTrader ==
On the main page of the Argo CD console, you should see a new tile that looks like this:
[.img_border_light]
image::/img/blog/configuration-drift-5.png[Liberty Dashboard,width=70%,align="center"]
Click the Sync button, then on the window that appears and click Sync again.
Click on the daytrader7 tile to view the app dashboard and sync progress.
Over the course of a few minutes, you should see resources being created and the app dashboard looking like this:
[.img_border_light]
image::/img/blog/configuration-drift-6.png[Liberty Dashboard,width=70%,align="center"]
Now the app is deployed and can be reached in a route created under the daytrader7 namespace. Find the URL via oc get routes –n daytrader7, then paste the URL in a browser.
And there we go! The app is fully deployed and ready to be used.
[.img_border_light]
image::/img/blog/configuration-drift-7.png[Liberty Dashboard,width=70%,align="center"]
// // // // // // // //
// LINKS
//
// OpenLiberty.io site links:
// link:/guides/microprofile-rest-client.html[Consuming RESTful Java microservices]
// 
// Off-site links:
// link:https://openapi-generator.tech/docs/installation#jar[Download Instructions]
//
// // // // // // // //
