---
layout: post
title: "Five Java Developer Must-Haves for Ultra-Fast Startup Solutions"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/vijaysun-omr
author_github: https://github.com/vijaysun-omr
seo-title: Five Java Developer Must-Haves for Ultra-Fast Startup Solutions - OpenLiberty.io
seo-description: Faster Java startup should not compromise developer experience, throughput performance, or security. We discuss how we achieved this with Liberty InstantOn.
blog_description: "Faster Java startup should not compromise developer experience, throughput performance, or security. We discuss how we achieved this with Liberty InstantOn."
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
additional_authors:
- name: Thomas Watson
  github: https://github.com/tjwatson
  image: https://avatars0.githubusercontent.com/tjwatson
- name: Laura Cowen
  github: https://github.com/lauracowen
  image: https://avatars0.githubusercontent.com/lauracowen
---
= Five Java Developer Must-Haves for Ultra-Fast Startup Solutions
Vijay Sundaresan <https://github.com/vijaysun-omr>
:imagesdir: /
:url-prefix:
:url-about: /
//Blank line here is necessary before starting the body of the post.


As more and more of our applications are being designed and developed to be deployed into the cloud, and we start to move towards microservice and even serverless style application architecture, start-up times are becoming ever more important. Unfortunately, although Java is a fantastic, robust language for us to use for developing enterprise applications, it isn't really known for it's quick start-up times. 

However, several solutions have recently emerged to help with this, speeding up Java startup. They range from compiling a link:https://www.graalvm.org/latest/reference-manual/native-image/[native image] that removes the JVM from the compiled app (the startup speed bottleneck in Java apps) to link:https://docs.azul.com/core/crac/crac-introduction[taking a snapshot of the application] after startup so that there are no startup tasks to complete when restored. But, most of these solutions suffer from compromises to developer experience, throughput performance, or security. 

What we really need is a solution that vastly improves the start-up time of Java applications, whilst also ensuring:
* It's easy for developers to implement in apps.
* It's easy for developers to use existing skills and APIs to write apps.
* It's easy for developers to enable on-the-fly configuration at deployment (restore) time. 
* The app's peak throughput performance is not degraded.
* The security of the app is not compromised.

In this article on DZone, IBM's Hybrid Cloud Performance Architect and the Chief Architect for Java at IBM explore each of these considerations and how they've been able to achieve fast start-up without compromising on any of them with Liberty InstantOn!

== Liberty InstantOn Checkpoint/Restore Solution

Liberty InstantOn is a checkpoint/restore-based solution for the fast startup of Java applications in serverless environments. Unlike other solutions, Liberty InstantOn was co-designed from the outset by the development teams working on a JDK (link:https://developer.ibm.com/languages/java/semeru-runtimes/downloads/[IBM Semeru Runtimes], a free distribution of link:https://dzone.com/articles/openjdk-providers-to-take-note-of[OpenJDK] and Eclipse OpenJ9) and an application runtime (link:https://openliberty.io/[Open Liberty], an open-source Java application runtime). This collaboration reflects the many checkpoints and restores tasks that must be done collaboratively between the application runtime and the JDK: several changes were made to Liberty, either to delay tasks until after checkpointing (e.g., initialization of Liberty security features) or to complete them before checkpointing (e.g., waiting for background tasks to complete, such as ongoing JIT compilations and Liberty specific initializers).

The performance of three different applications was tested, without (baseline) and with Liberty InstantOn, measuring both the startup time of the application and the time taken to serve the first request. See the following two graphs for results and our blog for link:https://openliberty.io/blog/2023/06/29/rapid-startup-instanton.html[method details]. The three applications ranged from a very simple application with a single REST endpoint (link:https://github.com/HotswapProjects/pingperf-quarkus/[pingperf]) through a more complicated application using JPA and a remote database (link:https://github.com/johnaohara/quarkusRestCrudDemo/[Rest Crud]) to a full application using MicroProfile features (link:https://github.com/blueperf/acmeair-mainservice-java#acme-air-main-service---javaliberty/[AcmeAir Microservice Main]). 

[.img_border_light]
image::/img/blog/InstantOnStartupComparison.png[A graph showing the startup times of the three applications with and without InstantOn,width=70%,align="center"]

[.img_border_light]
image::/img/blog/InstantOnResponseTimeComparison.png[A graph showing the response times of the three applications with and without InstantOn,width=70%,align="center"]

As well as providing very fast startup and first response times, the collaborative Liberty InstantOn checkpoint/restore approach provides a better developer experience than removing the JVM completely or implementing a checkpoint/restore solution only at the JDK level and then just stating that many kinds of tasks should not be done before checkpoint.  

== Find out more:

Find out more about Liberty InstantOn and how it enables all of this without compromise in the the full article here: https://dzone.com/articles/five-java-developer-must-haves-for-ultra-fast-star