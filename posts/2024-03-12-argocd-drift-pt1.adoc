---
layout: post
title: "Configuration Drift: Why its bad and how to solve it with GitOps and ArgoCD"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/danielguinan1
author_github: https://github.com/danielguinan1
seo-title: Configuration Drift - Why it's bad and how to solve it with GitOps and ArgoCD - OpenLiberty.io
seo-description: Configuration drift can complicate deployments and jeopardize the stability of production environments. Find out how to solve configuration drift with the use of GitOps and ArgoCD.
blog_description: "Configuration drift can complicate deployments and jeopardize the stability of production environments. Find out how to solve configuration drift with the use of GitOps and ArgoCD."
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
additional_authors: 
- name: Monica Tamboli
  github: https://github.com/mtamboli
  image: https://avatars0.githubusercontent.com/mtamboli
- name: Grace Jansen
  github: https://github.com/GraceJansen
  image: https://avatars0.githubusercontent.com/GraceJansen
---
= Configuration Drift: Why it's bad and how to solve it with GitOps and ArgoCD
Daniel Guinan <https://github.com/danielguinan1>
:imagesdir: /
:url-prefix:
:url-about: /

In today's modern software ecosystem, despite many organizations embracing Continuous Integration and Continuous Deployment (CI/CD) methodologies, they still grapple with the persistent issue of configuration drift. This refers to the disparity between configurations as coded in repositories like Git and what's actively deployed. This drift not only complicates deployments but can also jeopardize the stability of production environments. 

As an example... imagine a scenario where a Continuous Deployment (CD) pipeline deploys an application to a Kubernetes cluster, with all configurations codified in a Git repository. Just like that shown in the image below...

[.img_border_light]
image::/img/blog/argocd1.png[,width=70%,align="center"]

Everything operates seamlessly. As time progresses, as shown in the next image, changes and updates are made to the application, these changes are committed to the Git repository and pushed to the deployed application, updating our app in production. All good so far.

[.img_border_light]
image::/img/blog/argocd2.png[,width=70%,align="center"]

However, a team member identifies a performance issue and, aiming for a quick fix, uses a kubectl command to directly tweak the resource allocations for a specific deployment. In this case, they've gone straight to the production deployment!

[.img_border_light]
image::/img/blog/argocd3.png[,width=70%,align="center"]

Although this might resolve the immediate problem, the cluster's state now diverges from what's documented in Git, and from what's deployed in the dev and staging environments. The next time a deployment occurs, unexpected behaviors might arise because the CD pipeline assumes the cluster matches the Git state. Additionally, other team members might remain unaware of this change, leading to potential troubleshooting challenges and operational inefficiencies down the line. 

This scenario describes an example of configuration drift and how this can easily occur within your own cloud-native applications.

== What is Configuration Drift? == 

Configuration drift is defined as the divergence of a system’s active configuration from its intended or expected state. While there can be different reasons for this drift, the most common cause is manual untracked changes made to a system. If unaddressed, drift can be time-consuming to rectify especially when the scale of a system increases. 

== Why is Configuration Drift bad? == 

The consequences of configuration drift can vary in severity from mildly inconvinient to extremely serious and business threatening. However, no matter the severity, configuration drift will result in liabilities and negative impacts upon your app, team and bussiness. Let's examine the potential consequences this could have...  

In the best case scenario, configuration drift can cause:

* Additional workload

* Lost productivity

* Reduced efficiency

* Downtime of nonessential services

* Difficult audits

At the other end of the spectrum, at worst, drifted configurations can be responsible for:

* Significant security vulnerabilities due to unpatched vulnerabilities or absent security protocols leading to cyberattacks and breaches

* Compliance violations resulting in fines and reputational damage

* Downtime of essential services

* Whole app failure

* Data loss from misconfigured backup and storage settings

* Unreliable behavior in production due to inconsistent deployment environments

The difficulty with configuration drift, is that the longer you leave these problems and the larger the differences in configuration, the worse these problems become, rapidly! If you allow many individual misconfigurations to pile up over time without addressing them, these will quickly compound together, resulting in configuration drift that once could have been an easy fix becoming a significant, major problem.

This is why it is critical that you mitigate and solve any potential configuration drift in your own applications.

== What causes Configuration Drift? == 

In the majority of cases, like the example at the start of this blog, configuration drift isn't intentional. Typically, it is caused by one or more of the following behaviors:

* Software patches that alter system configurations

* Software or hardware updates that conflict with existing configurations

* Poor communication (e.g. if one team does not inform other teams about a setting modification it made)

* Poor documentation (e.g. if config changes are not efectively documented, team members may not know how to properly configure systems)

* Human error (e.g. typos and other incorrect attributes)

* Ad-hoc manual changes by devs or admins (like the scenario we explored above)

So as you can see, there are many reasons why configuration drift happens. But, in essence, regardless of how it happens, configuration drift occurs when code changes get through without being monitored or approved.

What can make this even worse, is the potential for developers to create even more configuration drift trying to solve issues quickly that are caused by configuration drift. As they try to fix these problems, more code changes get pushed without proper review, monitoring, tracking or reporting, leading to even further inconsistency between the desired configurations and actual state. This viscious cycle can continue to snowball creating more and more drift and more serious problems!

So, how can we mitigate configuration drift, and what tools and strategies can we use?


== How do we solve Configuration Drift? == 

In order to solve configuration drift, we must reconcile any potential configuration differences and ensure consistency across our deployments.

To do this, we can utilise **GitOps** — a principle that revolves around using Git as the single source of truth for declarative infrastructure and applications. GitOps is a framework designed to streamline and optimize how operations and infrastructure are handled in the modern cloud-native landscape. GitOps revolves around four core principles: 

. Declarative Configuration

+
In GitOps, all resources and infrastructure are defined declaratively. This means the entire system – from infrastructure, networking, and even application deployments – is described in a manner where you state "what" you want, not "how" to achieve it. These declarations are usually made through config files or manifests. 

. Versioned and Immutable Source of Truth

+
Every declared configuration is stored in a version-controlled Git repository. This repository acts as the immutable source of truth for both infrastructure and application. Any change, be it a minor configuration tweak or a major system overhaul, is recorded as a commit, ensuring full traceability and history. 

. Automated Delivery

+
Once a change is committed to the Git repository, automated processes handle the deployment. This ensures that the live system is always in sync with the repository's declared state. If any difference arises – whether due to manual interventions, system failures, or other reasons – the GitOps process can either flag it or work to reconcile the live state to match the repository. 

. Closed-Loop Feedback & Control

+
Continuous feedback is integral to GitOps. Monitoring and alerting tools keep a watchful eye on the live environment, comparing its state to the repository. If discrepancies are detected, these tools alert operations teams or even trigger auto-correction processes, making sure the desired state, as defined in Git, is consistently maintained. 


GitOps is more than just a set of tools or practices. It's a cultural shift in how infrastructure and applications are managed, drawing from proven development practices and extending them to operations. By tightly integrating Git at the center of the operational framework, GitOps ensures reliability, transparency, and efficiency in modern deployment pipelines. In essence, GitOps ensures that the actual state of a cluster is always equal to the desired state in Git.

After understanding the principles of GitOps, it becomes evident that achieving its full potential requires tools designed with these principles in mind. Let's explore what tools we can use.

== How does ArgoCD help enable GitOps? == 

ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. It works by ensuring that a Kubernetes cluster's state matches the configurations defined in a Git repository. It facilitates the automatic deployment and synchronization of applications to the desired environments.  

Typical Continuous Deployment (CD) systems adhere to the first two GitOps principles: using declarative configurations and maintaining a versioned, immutable source of truth. They ensure that every piece of infrastructure or application change is defined declaratively and then stored in a version-controlled system like Git. However, when it comes to the latter two principles, ensuring automated delivery and maintaining closed-loop feedback & control, this is where many CD systems fall short, and tools like ArgoCD shine. 

How does Argo CD help with these two GitOps principles?

* Automated Delivery: ArgoCD continuously and automatically syncs applications when changes are committed to the Git repository. This ensures deployments are consistent with the repository, bridging the gap between development commits and operational deployments. 

* Closed-Loop Feedback & Control: ArgoCD's real-time monitoring of application performance ensures that the live state is always aligned with the Git repository's state. If a discrepancy is detected, ArgoCD offers visual representations of the divergence and provides mechanisms to reconcile those differences, ensuring constant alignment with the intended state. 

Integrating this into the application we explored at the start of this blog, you'll see ArgoCD added into our pipeline, ensuring that our cluster remains in sync with what is defined in our Git repository.

[.img_border_light]
image::/img/blog/argocd4.png[,width=70%,align="center"]

== How can we make use of GitOps and ArgoCD? == 

If you’d like to see how you can practically use GitOps principles and ArgoCD to deploy Open Liberty applications, we've provided a detailed tutorial style blog which follows on from this introductory blog. This follow-on blog takes you through, set-by-step, how you can take an existing Open Liberty application and introduce ArgoCD to help solve configuration drift in your own applications.  


== Summary and Next Steps == 

In this blog, we discussed what configuration drift is and why it's problematic. We also explored how the GitOps approach can prevent configuration drift. The benefits of GitOps, especially in ensuring deployment consistency, are clear. If you're thinking about improving your deployment methods or initiating a new project, we recommend considering GitOps for your application. 

Check out the next blog in this series to explore how to apply this learning to your own applications. 
