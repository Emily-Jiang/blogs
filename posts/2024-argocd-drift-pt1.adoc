---
layout: post
title: "Blog Post: A Solution to Configuration Drift – GitOps with ArgoCD"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/danielguinan1
author_github: https://github.com/danielguinan1
seo-title: A Solution to Configuration Drift – GitOps with ArgoCD - OpenLiberty.io
seo-description: Learn how to deploy an Open Liberty Application with GitOps
blog_description: "Learn how to deploy an Open Liberty Application with GitOps"
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
additional_authors: 
- name: Monica Tamboli
  github: https://github.com/mtamboli
  image: https://avatars0.githubusercontent.com/mtamboli
---
= Blog Post: A Solution to Configuration Drift – GitOps with ArgoCD
Daniel Guinan <https://github.com/danielguinan1>
:imagesdir: /
:url-prefix:
:url-about: /

In today's modern software ecosystem, while many organizations have embraced Continuous Integration and Continuous Deployment (CI/CD) methodologies, they still grapple with the persistent issue of configuration drift. This refers to the disparity between configurations as coded in repositories like Git and what's actively deployed. This drift not only complicates deployments but can also jeopardize the stability of production environments. 

As an example, imagine a scenario where a Continuous Deployment (CD) pipeline deploys an application to a Kubernetes cluster, with all configurations codified in a Git repository. Everything operates seamlessly. However, a team member identifies a performance issue and, aiming for a quick fix, uses a kubectl command to directly tweak the resource allocations for a specific deployment. Although this might resolve the immediate problem, the cluster's state now diverges from what's documented in Git. The next time a deployment occurs, unexpected behaviors might arise because the CD pipeline assumes the cluster matches the Git state. Additionally, other team members might remain unaware of this change, leading to potential troubleshooting challenges and operational inefficiencies down the line. 

 

== What is Configuration Drift? == 

Configuration drift is defined as the divergence of a system’s active configuration from its intended or expected state. While there can be different reasons for this drift, the most common cause is manual untracked changes made to a system. If unaddressed, drift can be time-consuming to rectify especially when scale of the system increases. Configuration drift can also pose security risks, such as unpatched vulnerabilities or absent security protocols. 

 

 

 

 

So, how can we reconcile this gap and ensure consistency across our deployments? 

The answer lies in GitOps — a principle that revolves around using Git as the single source of truth for declarative infrastructure and applications.  

== What is GitOps == 

GitOps is a framework designed to streamline and optimize how operations and infrastructure are handled in the modern cloud-native landscape. GitOps revolves around four core principles: 

* Declarative Configuration: In GitOps, all resources and infrastructure are defined declaratively. This means the entire system – from infrastructure, networking, and even application deployments – is described in a manner where you state "what" you want, not "how" to achieve it. These declarations are usually made through config files or manifests. 

* Versioned and Immutable Source of Truth: Every declared configuration is stored in a version-controlled Git repository. This repository acts as the immutable source of truth for both infrastructure and application. Any change, be it a minor configuration tweak or a major system overhaul, is recorded as a commit, ensuring full traceability and history. 

* Automated Delivery: Once a change is committed to the Git repository, automated processes handle the deployment. This ensures that the live system is always in sync with the repository's declared state. If any difference arises – whether due to manual interventions, system failures, or other reasons – the GitOps process can either flag it or work to reconcile the live state to match the repository. 

* Closed-Loop Feedback & Control: Continuous feedback is integral to GitOps. Monitoring and alerting tools keep a watchful eye on the live environment, comparing its state to the repository. If discrepancies are detected, these tools alert operations teams or even trigger auto-correction processes, making sure the desired state, as defined in Git, is consistently maintained. 

 

 

This picture illustrates that GitOps principles where actual state of cluster is always equal to desired state in Git. Of course, some tools are needed to make this possible. 

In essence, GitOps is more than just a set of tools or practices. It's a cultural shift in how infrastructure and applications are managed, drawing from proven development practices and extending them to operations. By tightly integrating Git at the center of the operational framework, GitOps ensures reliability, transparency, and efficiency in modern deployment pipelines. 

After understanding the principles of GitOps, it becomes evident that achieving its full potential requires tools designed with these principles in mind. 

== What is ArgoCD == 

 ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. 

ArgoCD works by ensuring that a Kubernetes cluster's state matches the configurations defined in a Git repository. It facilitates the automatic deployment and synchronization of applications to the desired environments.  

Typical Continuous Deployment (CD) systems adhere to the first two GitOps principles: using declarative configurations and maintaining a versioned, immutable source of truth. They ensure that every piece of infrastructure or application change is defined declaratively and then stored in a version-controlled system like Git. However, when it comes to the latter two principles, ensuring automated delivery and maintaining closed-loop feedback & control, this is where many CD systems fall short, and tools like ArgoCD shine. 

 

 

This picture illustrates argoCD tool deployed onto your cluster making sure that Cluster remains in synch with what is defined in the Git repository. 

 

* Automated Delivery: ArgoCD continuously and automatically syncs applications when changes are committed to the Git repository. This ensures deployments are consistent with the repository, bridging the gap between development commits and operational deployments. 

* Closed-Loop Feedback & Control: ArgoCD's real-time monitoring of application performance ensures that the live state is always aligned with the Git repository's state. If a discrepancy is detected, ArgoCD offers visual representations of the divergence and provides mechanisms to reconcile those differences, ensuring constant alignment with the intended state. 

== Next Steps == 

In this blog, we discussed what configuration drift is and why it's problematic. We also explored how the GitOps approach can prevent configuration drift. The benefits of GitOps, especially in ensuring deployment consistency, are clear. If you're thinking about improving your deployment methods or initiating a new project, we recommend considering GitOps for your application. 

If you’d like to see how you can practically use ArgoCD to deployOpen Liberty applications, see the next blog in series.  
